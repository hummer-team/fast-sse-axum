## 请作为rust技术专家，我们继续完成send_message，要求：
1. 客户端调用POST /v1/sse/events/{event_id}/types/{event_type}发送消息(生产者) 
2. 客户端传递JSON数据，MessagePackage
3. send_message URL路由部分代码：
```rust
Router::new().route("/v1/sse/events/{event_id}/types/{event_type}",post(send_message));
// 省略其他代码
```
4. send_message方法需要从订阅列表中CLIENT_SUBSCRIPTIONS检查当前event_id是否存在订阅，如果没有订阅则丢弃消息，如果event_id存在则把消息发送到内存队列中，并立即返回给客户端204状态码。如果event_id不存在订阅则记录waring日志，并返回403状态码。
5. 请仔细检查代码，完全正确后再返回

### 请作为rust技术专家，我们继续完善send_message
##### Context (C)：
1. 代码如下
```rust
pub async fn send_message(
        Path((event_id, event_type)): Path<(String, String)>,
        Json(message): Json<MessagePackage>,
    ) -> (StatusCode, Json<ResourceResponse<()>>) {
        let has_subscription = {
            let subs = CLIENT_SUBSCRIPTIONS.get().unwrap().read().await;
            subs.contains_key(&event_id)
        };
        if !has_subscription {
            return (
                StatusCode::FORBIDDEN,
                Json(ResourceResponse::error(
                    "FORBIDDEN",
                    "No active subscription for this event_id",
                )),
            );
        }
        let broadcaster = SSE_BROAD_CAST.get().unwrap();

        match broadcaster.send(message) {
            Ok(_) => {
                info!(
                    "message send success {} {}",
                    event_id,
                    message.clone().message_id
                );
                return (StatusCode::NO_CONTENT, Json(ResourceResponse::ok(None)));
            }
            Err(broadcast::error::SendError(dropped_msg)) => {
                error!("send message failed {}", event_id);
                return (
                    StatusCode::SERVICE_UNAVAILABLE,
                    Json(ResourceResponse::error(
                        "SERVICE_UNAVAILABLE",
                        "Broadcast queue unavailable",
                    )),
                );
            }
        }
    }
```    
2. 需要解决的错误
   - broadcaster.send(message) 编译器报错： move occurs because `message` has type `MessagePackage`, which does not implement the `Copy`
   - message.clone().message_id consider cloning the value if the performance cost is acceptable: `.clone()`   

#### Output or Objective (O)：
1. 解决上述错误，并给出代码实现

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家 

#### Requirements or Response (R)：
1. 给出的代码请仔细检查，
2. 实现要完整
---
### 请作为rust技术专家，我们继续完善subscribert
##### Context (C)：
1. 相关代码如下
```rust
static CLIENT_SUBSCRIPTIONS: OnceLock<
        RwLock<HashMap<String, broadcast::Sender<serde_json::Value>>>,
    > = OnceLock::new();
static SSE_BROAD_CAST: OnceLock<broadcast::Sender<serde_json::Value>> = OnceLock::new();

pub async fn subscribert(
        Path((event_id, event_type)): Path<(String, String)>,
    ) -> (StatusCode, Json<ResourceResponse<()>>) {
        let subscriptions = CLIENT_SUBSCRIPTIONS.get().unwrap();
        let mut r = subscriptions.write().await;
        if r.contains_key(&event_id) {
            return (StatusCode::OK, Json(ResourceResponse::ok(None)));
        }
        info!("Subscribed to event: {} {}", event_id, event_type);
        let tx = SSE_BROAD_CAST.get().unwrap().clone();
        r.insert(event_id, tx);

        (StatusCode::OK, Json(ResourceResponse::ok(None)))
    }
```    
1. 背景需求
   - 如果有多个客户端订阅不同的事件比如A订阅001，003，B订阅002，需要把001，003，002存储到CLIENT_SUBSCRIPTIONS

#### Output or Objective (O)：
1. SSE Server对于A订阅的两个事件，应该是两个SSE实例对于A订阅的两个事件（如spring boot的SseEmitter）
2. 订阅成功后返回ResourceResponse
3. 原先定义的SSE_BROAD_CAST是否是多余的变量？，因为CLIENT_SUBSCRIPTIONS已经关联了事件，SSE Stream实例

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家 

#### Requirements or Response (R)：
1. 给出完整的方案解答
2. 实现要完整
3. 不要发散，紧扣我的问题

---
### 请作为rust技术专家，我们继续完善subscribert
##### Context (C)：
1. 相关代码如下
```rust
pub async fn subscribert(Path((event_id, event_type)): Path<(String, String)>) -> Response {
        let receiver = {
            let mut subs = CLIENT_SUBSCRIPTIONS.get().unwrap().write().await;
            // 获取或创建通道
            let sender = subs
                .entry(event_id.clone())
                .or_insert_with(|| {
                    let (tx, _rx) = broadcast::channel::<Value>(1024);
                    info!("create channel: {} (type: {})", event_id, event_type);
                    tx
                })
                .clone();
            sender.subscribe()
        };
        info!(
            "客户端订阅事件: {} / {} (活跃接收者: {})",
            event_id,
            event_type,
            receiver.len()
        );

        let stream = async_stream::stream! {
            let mut rx = receiver;
            loop {
                match rx.recv().await {
                    Ok(json_value) => {
                        // 成功接收消息，推送给客户端
                        yield Ok::<_, Infallible>(
                            Event::default()
                                .json_data(json_value)
                                .unwrap_or_else(|_| Event::default().data("serialization error"))
                        );
                    }
                    Err(broadcast::error::RecvError::Lagged(count)) => {
                        warn!("客户端落后，跳过 {} 条消息,event_id {}",count,event_id);
                        yield Ok(Event::default()
                            .event("error")
                            .json_data(serde_json::json!({
                                "code": "LAGGED",
                                "message": format!("Skipped {} messages", count)
                            }))
                            .unwrap()
                        );
                    }
                    Err(broadcast::error::RecvError::Closed) => {
                        info!("SSE channel closed: event_id={}", event_id);
                        break;
                    }
                }
            }
        };
        Sse::new(stream)
            .keep_alive(
                KeepAlive::new()
                    .interval(Duration::from_secs(60))
                    .text("keep-alive"),
            )
            .into_response()
    }
```    
#### Output or Objective (O)：
1. 问题1:failed to resolve: use of unresolved module or unlinked crate `async_stream`
use of unresolved module or unlinked crate `async_stream`
2. 问题2:failed to resolve: use of undeclared type `KeepAlive`
use of undeclared type `KeepAlive`订阅成功后返回ResourceResponse

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家 

#### Requirements or Response (R)：
1. 给出完整的方案解答
2. 实现要完整
3. 不要发散，紧扣我的问题
---
### 请作为rust技术专家，我们继续完善send_message
#### Context (C)：
1. 相关代码如下
```rust
pub async fn send_message(
        Path((event_id, _event_type)): Path<(String, String)>,
        Json(message): Json<MessagePackage>,
    ) -> (StatusCode, Json<ResourceResponse<()>>) {
        let sse_sender = {
            let subs = CLIENT_SUBSCRIPTIONS.get().unwrap().read().await;
            subs.get(&event_id).cloned();
        };
        let Some(sender) = sse_sender else {
            warn!(
                "event_id = {},event_type = {},无活跃SSE订阅，消息被丢弃",
                event_id, _event_type
            );
            return (
                StatusCode::FORBIDDEN,
                Json(ResourceResponse::error(
                    "403",
                    "No active subscription for this event_id",
                )),
            );
        };

        match sender.send(message.data) {
            Ok(receivers_count) => {
                info!(
                    "event_id = {},event_type = {},receivers = {},消息广播成功",
                    event_id, _event_type, receivers_count
                );
                (StatusCode::NO_CONTENT, Json(ResourceResponse::ok(None)))
            }
            Err(broadcast::error::SendError(dropped)) => {
                error!(
                    "event_id = {},event_type = {},消广播队列已满，消息丢失息广播成功",
                    event_id, _event_type
                );

                // 可选：将 dropped 消息记录到持久化日志
                // log_dropped_message(dropped);
                (
                    StatusCode::SERVICE_UNAVAILABLE,
                    Json(ResourceResponse::error("503", "Broadcast queue full")),
                )
            }
        }
    }    
```    
#### Output or Objective (O)：
1. 问题1:subs.get(&event_id).cloned(); ，如果event并没有订阅，这里是不是会报错？
2. 问题2:let Some(sender) = sse_sender else 编译器报错：mismatched types expected unit type `()` found enum `std::option::Option<_>`

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家

#### Requirements or Response (R)：
1. 给出完整的，严谨方案解答
2. 代码需要完整
3. 不要发散，紧扣我的问题
4. 注释，日志内容中不要出现emoji
---

### 请作为rust技术专家，我们继续完善fn send_message
#### Context (C)：
1. 相关代码如下
```rust
pub async fn send_message(
        Path((event_id, _event_type)): Path<(String, String)>,
        Json(message): Json<MessagePackage>,
    ) -> Response {
        let sse_sender = {
            let subs = CLIENT_SUBSCRIPTIONS.get().unwrap().read().await;
            if let Some(meta) = subs.get(&event_id) {
                // * 表示解引用
                *meta.last_activity.lock().unwrap() = Instant::now();
                Some(meta.sender.clone())
            } else {
                None
            }
        }; // free the lock

        let Some(sender) = sse_sender else {
            warn!(
                "event_id = {},event_type = {},无活跃SSE订阅，消息被丢弃",
                event_id, _event_type
            );
            return Response::builder()
                .status(StatusCode::FORBIDDEN)
                .header(header::CONTENT_TYPE, "application/json")
                .header(header::CONNECTION, "close")
                .body(
                    Json(ResourceResponse::<()>::error(
                        "403",
                        "No active subscription",
                    ))
                    .into_response()
                    .into_body(),
                )
                .unwrap();
        };

        match sender.send(message.data.unwrap()) {
            Ok(receivers_count) => {
                info!(
                    "event_id = {},event_type = {},receivers = {},消息广播成功",
                    event_id, _event_type, receivers_count
                );
                Response::builder()
                    .status(StatusCode::NO_CONTENT)
                    .header(header::CONNECTION, "close")
                    .body(
                        Json(ResourceResponse::<()>::ok(None))
                            .into_response()
                            .into_body(),
                    )
                    .unwrap()
            }
            Err(broadcast::error::SendError(dropped)) => {
                error!(
                    "event_id = {},event_type = {},消广播队列已满，消息丢失息 {}",
                    event_id, _event_type, dropped
                );

                // 可选：将 dropped 消息记录到持久化日志
                // log_dropped_message(dropped);
                Response::builder()
                    .status(StatusCode::OK)
                    .header(header::CONTENT_TYPE, "application/json")
                    .header(header::CONNECTION, "close")
                    .body(
                        Json(ResourceResponse::<()>::error("OK", "Broadcast queue full"))
                            .into_response()
                            .into_body(),
                    )
                    .unwrap()
            }
        }
    } 
```    
#### Output or Objective (O)：
1. 问题1:Response 代码是否可以简化？，如果不能则封装为函数send_message调用即可

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家，期望时非常**严谨，完整的回答**

#### Requirements or Response (R)：
1. 给出完整的，严谨方案解答
2. 代码需要完整
3. 不要发散，紧扣我的问题
4. 注释，日志内容中不要出现emoji符号

---
### 请作为rust技术专家，我们继续改进send_message的问题
#### Context (C)：
1. 相关代码如下
```rust
 pub fn app() -> Router {
        let assets_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("assets");
        info!("Serving static files from {}", assets_dir.display());
        let static_files_service = ServeDir::new(assets_dir).append_index_html_on_directories(true);

        let allowed_ids = std::env::var("ALLOWED_EVENT_IDS")
            .unwrap_or_default()
            .split(',')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect();

        let allowed_events = std::env::var("ALLOWED_EVENT_TYPES")
            .unwrap_or_default()
            .split(',')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect();

        let secret = std::env::var("HMAC_SECRET")
            .expect("HMAC_SECRET must be set")
            .into_bytes();

        let config = Arc::new(AuthConfig::new(allowed_ids, secret, allowed_events));

        // build our application with a route
        let router = Router::new()
            .fallback_service(static_files_service)
            .route(
                "/v1/sse/events/{event_id}/types/{event_type}",
                get(subscribert), // http method is get
            )
            .route(
                "/v1/sse/events/{event_id}/types/{event_type}",
                post(send_message), // http method is post
            )
            .layer(from_fn_with_state(config.into(), auth))
            .layer(TraceLayer::new_for_http());
        info!("sse router register success");
        router
    }

pub async fn send_message(
        Path((event_id, _event_type)): Path<(String, String)>,
        Json(message): Json<MessagePackage>,
    ) -> Response {
        let sse_sender = {
            let subs = CLIENT_SUBSCRIPTIONS.get().unwrap().read().await;
            if let Some(meta) = subs.get(&event_id) {
                // * 表示解引用
                *meta.last_activity.lock().unwrap() = Instant::now();
                Some(meta.sender.clone())
            } else {
                None
            }
        }; // free the lock

        let Some(sender) = sse_sender else {
            warn!(
                "event_id = {},event_type = {},无活跃SSE订阅，消息被丢弃",
                event_id, _event_type
            );
            return Response::builder()
                .status(StatusCode::FORBIDDEN)
                .header(header::CONTENT_TYPE, "application/json")
                .header(header::CONNECTION, "close")
                .body(
                    Json(ResourceResponse::<()>::error(
                        "403",
                        "No active subscription",
                    ))
                    .into_response()
                    .into_body(),
                )
                .unwrap();
        };

        match sender.send(message.data.unwrap()) {
            Ok(receivers_count) => {
                info!(
                    "event_id = {},event_type = {},receivers = {},消息广播成功",
                    event_id, _event_type, receivers_count
                );
                Response::builder()
                    .status(StatusCode::NO_CONTENT)
                    .header(header::CONNECTION, "close")
                    .body(
                        Json(ResourceResponse::<()>::ok(None))
                            .into_response()
                            .into_body(),
                    )
                    .unwrap()
            }
            Err(broadcast::error::SendError(dropped)) => {
                error!(
                    "event_id = {},event_type = {},消广播队列已满，消息丢失息 {}",
                    event_id, _event_type, dropped
                );

                // 可选：将 dropped 消息记录到持久化日志
                // log_dropped_message(dropped);
                Response::builder()
                    .status(StatusCode::OK)
                    .header(header::CONTENT_TYPE, "application/json")
                    .header(header::CONNECTION, "close")
                    .body(
                        Json(ResourceResponse::<()>::error("OK", "Broadcast queue full"))
                            .into_response()
                            .into_body(),
                    )
                    .unwrap()
            }
        }
    }
```    
#### Output or Objective (O)：
1. 不修改路由仅修改send_message增加.header(header::CONNECTION, "close") 即可在发送消息后立即返回，这样改动是否合理？

#### Assumptions or Audience (A)：
1. 你面向的读者是高级技术专家

#### Requirements or Response (R)：
1. 给出完整的，严谨方案解答
2. 代码需要完整
3. 不要发散，紧扣我的问题
4. 注释，日志内容中不要出现emoji


---
## 提示词模板

##### Context (C)：
- 撰写一篇小红书种草博文，推荐一款最新的护肤产品。
- 这篇博文的背景是为了推广一款最新的护肤产品，该产品主打成分为玻尿酸，适合所有肤质，特别是干性和敏感性肌肤
- 目标读者是22-30岁的年轻人，他们关注护肤和美容趋势，喜欢尝试新产品

#### Output or Objective (O)：
- 介绍这款护肤产品的主要特点和优势
- 通过详细描述使用体验，激发读者的购买欲望

#### Specificity or Style (S)：
- 采用亲切、活泼的风格，融入生活化的语言
- 小红书博文风格，需要包含诸如“宝子”，“姐妹”等词汇，以及丰富的emoji

#### Task or Tone (T)：
- 友好、热情、激动、开心，像朋友间的推荐

#### Assumptions or Audience (A)：
- 22-30岁的年轻人，特别是注重护肤和美容的女性读者

#### Requirements or Response (R)：
- 博文应包括产品介绍、使用体验、效果描述和推荐理由
- 如果文中有列表，那么列表的每一项开头都需要有 emoji